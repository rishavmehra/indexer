// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDBCredential = `-- name: CreateDBCredential :one
INSERT INTO db_credentials (
    user_id,
    db_host,
    db_port,
    db_name,
    db_user,
    db_password,
    db_ssl_mode
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, db_host, db_port, db_name, db_user, db_password, db_ssl_mode, created_at, updated_at
`

type CreateDBCredentialParams struct {
	UserID     pgtype.UUID `json:"userId"`
	DbHost     string      `json:"dbHost"`
	DbPort     int32       `json:"dbPort"`
	DbName     string      `json:"dbName"`
	DbUser     string      `json:"dbUser"`
	DbPassword string      `json:"dbPassword"`
	DbSslMode  string      `json:"dbSslMode"`
}

func (q *Queries) CreateDBCredential(ctx context.Context, arg CreateDBCredentialParams) (DbCredential, error) {
	row := q.db.QueryRow(ctx, createDBCredential,
		arg.UserID,
		arg.DbHost,
		arg.DbPort,
		arg.DbName,
		arg.DbUser,
		arg.DbPassword,
		arg.DbSslMode,
	)
	var i DbCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbHost,
		&i.DbPort,
		&i.DbName,
		&i.DbUser,
		&i.DbPassword,
		&i.DbSslMode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createIndexer = `-- name: CreateIndexer :one
INSERT INTO indexers (
    user_id,
    db_credential_id,
    indexer_type,
    params,
    target_table,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at
`

type CreateIndexerParams struct {
	UserID         pgtype.UUID     `json:"userId"`
	DbCredentialID pgtype.UUID     `json:"dbCredentialId"`
	IndexerType    IndexerType     `json:"indexerType"`
	Params         json.RawMessage `json:"params"`
	TargetTable    string          `json:"targetTable"`
	Status         IndexerStatus   `json:"status"`
}

func (q *Queries) CreateIndexer(ctx context.Context, arg CreateIndexerParams) (Indexer, error) {
	row := q.db.QueryRow(ctx, createIndexer,
		arg.UserID,
		arg.DbCredentialID,
		arg.IndexerType,
		arg.Params,
		arg.TargetTable,
		arg.Status,
	)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbCredentialID,
		&i.IndexerType,
		&i.Params,
		&i.TargetTable,
		&i.WebhookID,
		&i.Status,
		&i.LastIndexedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createIndexingLog = `-- name: CreateIndexingLog :one
INSERT INTO indexing_logs (
    indexer_id,
    event_type,
    message,
    details
) VALUES (
    $1, $2, $3, $4
) RETURNING id, indexer_id, event_type, message, details, created_at
`

type CreateIndexingLogParams struct {
	IndexerID pgtype.UUID     `json:"indexerId"`
	EventType string          `json:"eventType"`
	Message   string          `json:"message"`
	Details   json.RawMessage `json:"details"`
}

func (q *Queries) CreateIndexingLog(ctx context.Context, arg CreateIndexingLogParams) (IndexingLog, error) {
	row := q.db.QueryRow(ctx, createIndexingLog,
		arg.IndexerID,
		arg.EventType,
		arg.Message,
		arg.Details,
	)
	var i IndexingLog
	err := row.Scan(
		&i.ID,
		&i.IndexerID,
		&i.EventType,
		&i.Message,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email,
    password_hash
) VALUES (
    $1, $2
) RETURNING id, email, password_hash, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"passwordHash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDBCredential = `-- name: DeleteDBCredential :exec
DELETE FROM db_credentials
WHERE id = $1 AND user_id = $2
`

type DeleteDBCredentialParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"userId"`
}

func (q *Queries) DeleteDBCredential(ctx context.Context, arg DeleteDBCredentialParams) error {
	_, err := q.db.Exec(ctx, deleteDBCredential, arg.ID, arg.UserID)
	return err
}

const deleteIndexer = `-- name: DeleteIndexer :exec
DELETE FROM indexers
WHERE id = $1 AND user_id = $2
`

type DeleteIndexerParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"userId"`
}

func (q *Queries) DeleteIndexer(ctx context.Context, arg DeleteIndexerParams) error {
	_, err := q.db.Exec(ctx, deleteIndexer, arg.ID, arg.UserID)
	return err
}

const getActiveIndexers = `-- name: GetActiveIndexers :many
SELECT id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at FROM indexers
WHERE status = 'active'
`

func (q *Queries) GetActiveIndexers(ctx context.Context) ([]Indexer, error) {
	rows, err := q.db.Query(ctx, getActiveIndexers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Indexer{}
	for rows.Next() {
		var i Indexer
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DbCredentialID,
			&i.IndexerType,
			&i.Params,
			&i.TargetTable,
			&i.WebhookID,
			&i.Status,
			&i.LastIndexedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDBCredentialByID = `-- name: GetDBCredentialByID :one
SELECT id, user_id, db_host, db_port, db_name, db_user, db_password, db_ssl_mode, created_at, updated_at FROM db_credentials
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDBCredentialByID(ctx context.Context, id pgtype.UUID) (DbCredential, error) {
	row := q.db.QueryRow(ctx, getDBCredentialByID, id)
	var i DbCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbHost,
		&i.DbPort,
		&i.DbName,
		&i.DbUser,
		&i.DbPassword,
		&i.DbSslMode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDBCredentialsByUserID = `-- name: GetDBCredentialsByUserID :many
SELECT id, user_id, db_host, db_port, db_name, db_user, db_password, db_ssl_mode, created_at, updated_at FROM db_credentials
WHERE user_id = $1
`

func (q *Queries) GetDBCredentialsByUserID(ctx context.Context, userID pgtype.UUID) ([]DbCredential, error) {
	rows, err := q.db.Query(ctx, getDBCredentialsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DbCredential{}
	for rows.Next() {
		var i DbCredential
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DbHost,
			&i.DbPort,
			&i.DbName,
			&i.DbUser,
			&i.DbPassword,
			&i.DbSslMode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexerByID = `-- name: GetIndexerByID :one
SELECT id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at FROM indexers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetIndexerByID(ctx context.Context, id pgtype.UUID) (Indexer, error) {
	row := q.db.QueryRow(ctx, getIndexerByID, id)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbCredentialID,
		&i.IndexerType,
		&i.Params,
		&i.TargetTable,
		&i.WebhookID,
		&i.Status,
		&i.LastIndexedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIndexerByWebhookID = `-- name: GetIndexerByWebhookID :one
SELECT id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at FROM indexers
WHERE webhook_id = $1 LIMIT 1
`

func (q *Queries) GetIndexerByWebhookID(ctx context.Context, webhookID pgtype.Text) (Indexer, error) {
	row := q.db.QueryRow(ctx, getIndexerByWebhookID, webhookID)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbCredentialID,
		&i.IndexerType,
		&i.Params,
		&i.TargetTable,
		&i.WebhookID,
		&i.Status,
		&i.LastIndexedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIndexersByUserID = `-- name: GetIndexersByUserID :many
SELECT id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at FROM indexers
WHERE user_id = $1
`

func (q *Queries) GetIndexersByUserID(ctx context.Context, userID pgtype.UUID) ([]Indexer, error) {
	rows, err := q.db.Query(ctx, getIndexersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Indexer{}
	for rows.Next() {
		var i Indexer
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DbCredentialID,
			&i.IndexerType,
			&i.Params,
			&i.TargetTable,
			&i.WebhookID,
			&i.Status,
			&i.LastIndexedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexingLogsByIndexerID = `-- name: GetIndexingLogsByIndexerID :many
SELECT id, indexer_id, event_type, message, details, created_at FROM indexing_logs
WHERE indexer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetIndexingLogsByIndexerIDParams struct {
	IndexerID pgtype.UUID `json:"indexerId"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetIndexingLogsByIndexerID(ctx context.Context, arg GetIndexingLogsByIndexerIDParams) ([]IndexingLog, error) {
	rows, err := q.db.Query(ctx, getIndexingLogsByIndexerID, arg.IndexerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IndexingLog{}
	for rows.Next() {
		var i IndexingLog
		if err := rows.Scan(
			&i.ID,
			&i.IndexerID,
			&i.EventType,
			&i.Message,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDBCredential = `-- name: UpdateDBCredential :one
UPDATE db_credentials
SET
    db_host = $2,
    db_port = $3,
    db_name = $4,
    db_user = $5,
    db_password = $6,
    db_ssl_mode = $7,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, db_host, db_port, db_name, db_user, db_password, db_ssl_mode, created_at, updated_at
`

type UpdateDBCredentialParams struct {
	ID         pgtype.UUID `json:"id"`
	DbHost     string      `json:"dbHost"`
	DbPort     int32       `json:"dbPort"`
	DbName     string      `json:"dbName"`
	DbUser     string      `json:"dbUser"`
	DbPassword string      `json:"dbPassword"`
	DbSslMode  string      `json:"dbSslMode"`
}

func (q *Queries) UpdateDBCredential(ctx context.Context, arg UpdateDBCredentialParams) (DbCredential, error) {
	row := q.db.QueryRow(ctx, updateDBCredential,
		arg.ID,
		arg.DbHost,
		arg.DbPort,
		arg.DbName,
		arg.DbUser,
		arg.DbPassword,
		arg.DbSslMode,
	)
	var i DbCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbHost,
		&i.DbPort,
		&i.DbName,
		&i.DbUser,
		&i.DbPassword,
		&i.DbSslMode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateIndexerStatus = `-- name: UpdateIndexerStatus :one
UPDATE indexers
SET
    status = $2,
    error_message = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at
`

type UpdateIndexerStatusParams struct {
	ID           pgtype.UUID   `json:"id"`
	Status       IndexerStatus `json:"status"`
	ErrorMessage pgtype.Text   `json:"errorMessage"`
}

func (q *Queries) UpdateIndexerStatus(ctx context.Context, arg UpdateIndexerStatusParams) (Indexer, error) {
	row := q.db.QueryRow(ctx, updateIndexerStatus, arg.ID, arg.Status, arg.ErrorMessage)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbCredentialID,
		&i.IndexerType,
		&i.Params,
		&i.TargetTable,
		&i.WebhookID,
		&i.Status,
		&i.LastIndexedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateIndexerWebhookID = `-- name: UpdateIndexerWebhookID :one
UPDATE indexers
SET
    webhook_id = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at
`

type UpdateIndexerWebhookIDParams struct {
	ID        pgtype.UUID `json:"id"`
	WebhookID pgtype.Text `json:"webhookId"`
}

func (q *Queries) UpdateIndexerWebhookID(ctx context.Context, arg UpdateIndexerWebhookIDParams) (Indexer, error) {
	row := q.db.QueryRow(ctx, updateIndexerWebhookID, arg.ID, arg.WebhookID)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbCredentialID,
		&i.IndexerType,
		&i.Params,
		&i.TargetTable,
		&i.WebhookID,
		&i.Status,
		&i.LastIndexedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLastIndexedTime = `-- name: UpdateLastIndexedTime :one
UPDATE indexers
SET
    last_indexed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, db_credential_id, indexer_type, params, target_table, webhook_id, status, last_indexed_at, error_message, created_at, updated_at
`

func (q *Queries) UpdateLastIndexedTime(ctx context.Context, id pgtype.UUID) (Indexer, error) {
	row := q.db.QueryRow(ctx, updateLastIndexedTime, id)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DbCredentialID,
		&i.IndexerType,
		&i.Params,
		&i.TargetTable,
		&i.WebhookID,
		&i.Status,
		&i.LastIndexedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
